<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>事件对象</title>
		<style>
			div{
				width:200px;
				height: 200px;
				background: red;
			}
			li{
				width:400px;
				height: 50px;
				background: lightblue;
				margin-top: 10px;
			}
		</style>
	</head>
	<body>
		<div id="box"></div>
		<ul>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
			<li></li>
		</ul>
	</body>
	<script>
		var box = document.getElementById('box');
//		box.onclick = function(){
//			console.log(event);
//		}
		console.log(event);
		
		//event 事件对象
		//只有在事件处理函数中才能拿到
		//event对象默认在火狐浏览器下是不存在，我们需要通过传递参数的形式才能拿到event对象
		
		document.onclick = function(event){
			var ev = event || window.event;
			//在IE下，是window.event
			console.log(ev);
		}
		
		//target  事件源：返回的是触发事件的节点
		
		//利用事件源（target）和事件冒泡，我们可以做事件代理
		var li = document.getElementsByTagName('li');
		var ul = document.getElementsByTagName('ul')[0];
//		for(var i = 0; i < li.length; i++){
//			li[i].index = i;
//			li[i].onclick = function(){
//				for(var i = 0 ; i < li.length; i++){
//					li[i].style.border = "";
//				}
//				this.style.border = "2px pink solid";
//			}
//		}
//		var oLi = document.createElement('li');
//		ul.appendChild(oLi);

		ul.onclick = function(){
			for(var i = 0; i < li.length; i++){
				li[i].style.border = "";
			}
			event.target.style.border = "2px pink solid";
		}
		var oLi = document.createElement('li');
		ul.appendChild(oLi);
		
		//事件代理（事件委托） 原理：事件冒泡
		//优点：1.管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件
		//2.可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。
		//3.JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。
		
		
		
	</script>
</html>
